"""
이 문제는 DFS만 사용하면 시간 초과가 날 수 있기 때문에, 불필요한 중복을 줄이기 위해서 DP 도 함께 사용해하는 문제입니다.
처음에는 DFS로만 풀려고 해서, 현재 위치와 상,하,좌,우 값을 비교해서 현재 값보다 더 작은 방향으로만 나아갈 수 있게 로직을 짜야겠다 했는데
그 로직을 DP로 짜야 하는 것 이였습니다.

이 코드는 DFS (Depth-First Search) 알고리즘을 사용하여 푸는 문제입니다. 
DFS 알고리즘은 스택 자료구조 또는 재귀 함수를 이용하여 구현할 수 있으며, 이 코드에서는 재귀 함수를 이용하여 구현하였습니다.

이 코드에서 dfs 함수는 현재 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 구하는 함수입니다. 
이때, dp 배열을 이용하여 이미 방문한 위치에서 출발하는 경우의 수를 미리 저장하고, 이를 활용하여 재귀적으로 dfs 함수를 호출합니다. 
이는 중복 계산을 방지하여 시간복잡도를 줄일 수 있습니다.

[코드에서 사용된 변수]

m, n: 각각 지도의 세로, 가로 길이를 나타냅니다.
graph: 지도를 나타내는 2차원 배열입니다.
dp: 이미 방문한 위치에서 출발하는 경우의 수를 저장하는 2차원 배열입니다.
dx, dy: 상, 하, 좌, 우로 이동하는 경우의 좌표 차이를 나타내는 리스트입니다.

[코드의 전체적인 동작]

1. 입력받은 지도를 graph에 저장합니다. 이때, 각 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 저장하기 위해 dp 배열을 -1로 초기화합니다.

2. dfs 함수를 호출하여 시작 위치 (0, 0)에서 출발하여 도착지점까지 도달하는 경우의 수를 구합니다.

3. dfs 함수에서 현재 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 반환합니다. 
이때, 이미 방문한 위치에서 출발하는 경우의 수가 dp 배열에 저장되어 있다면 이를 활용하여 중복 계산을 방지합니다.

4. dfs 함수에서는 현재 위치에서 갈 수 있는 위치를 모두 확인하며, 각 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 누적하여 반환합니다.

5. dfs 함수의 실행이 종료되면, 시작 위치에서 출발하여 도착지점까지 도달하는 경우의 수가 dp 배열에 저장됩니다.

6. dfs 함수의 실행이 종료된 후, dfs(0,0)을 출력하여 시작 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 출력합니다.

[dp 배열을 -1로 초기화 하는 이유]
DP 배열을 -1로 초기화하는 것은 해당 위치를 아직 방문하지 않았음을 의미하는 특별한 값으로 사용하기 위함입니다. 

이렇게 초기화하면, 해당 위치에 대한 계산을 아직 수행하지 않았다는 것을 나타내기 때문에, 
해당 위치에서부터 출발하는 모든 경로의 수를 계산해야 할 때 매번 재귀 호출을 수행하지 않고, 이전에 계산한 값을 그대로 사용할 수 있습니다.

만약 DP 배열을 0으로 초기화하게 되면, 이미 계산한 값과 아직 계산하지 않은 값 모두를 0으로 구분할 수 없기 때문에, 
재귀 호출을 반복해서 수행하게 됩니다. 이는 시간 복잡도를 높여 성능에 문제가 생길 수 있습니다.

따라서, DP 배열을 -1로 초기화하고, 이미 방문한 적이 있는 경우에는 해당 위치에서 출발하는 경우의 수를 그대로 반환하게 되어 효율적인 계산을 할 수 있습니다.

[dp점화식]
이 코드는 DFS + DP를 활용한 문제풀이 방법을 사용하고 있습니다.

이 문제에서 DP 배열의 값 dp[i][j]는 (i, j) 지점에서 출발하여 (m-1, n-1) 지점에 도착하는 경로의 수를 나타냅니다. 
즉, dp[i][j]를 구하기 위해서는 이전에 계산한 dp[x][y] 값들을 활용해야 합니다. 이때, dp[i][j]는 다음과 같이 점화식으로 표현할 수 있습니다.

dp[i][j] = dp[x][y] (if (i, j)에서 (x, y)로 갈 수 있는 경우)

여기서 (i, j) 지점에서 (x, y) 지점으로 갈 수 있는 조건은 graph[i][j] > graph[x][y]인 경우입니다. 이는 (i, j)에서 (x, y)로 내려갈 수 있는 경우를 의미합니다. 
이전에 계산한 dp[x][y] 값을 활용하여 dp[i][j] 값을 구하는 것이 DFS + DP 문제 해결 방법의 핵심입니다.

따라서, 이 코드에서는 DFS를 활용하여 (0, 0) 지점에서 출발하여 (m-1, n-1) 지점까지 도착하는 모든 경로의 수를 구하고, 
이전에 계산한 값이 있다면 그 값을 활용하여 DP를 수행합니다. 이때, DP 배열은 -1로 초기화하여 아직 계산하지 않은 값임을 나타냅니다.

[예제 입력 넣었을 때 자세한 동작 과정]

이 지도에서 시작 위치는 (0, 0)이고, 도착지점은 (3, 4)입니다.

이 코드는 재귀적으로 호출되는 dfs 함수를 통해 시작 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 구합니다.

먼저, dfs(0, 0)이 호출되면 현재 위치 (0, 0)에서 출발하여 도착지점 (3, 4)까지 도달하는 경우의 수를 반환하게 됩니다. 이때, 이미 방문한 위치에서 출발하는 경우의 수가 dp 배열에 저장되어 있으면 이를 활용하여 중복 계산을 방지합니다.

(0, 0)에서 갈 수 있는 위치는 오른쪽 (0, 1)과 아래쪽 (1, 0)입니다. (0, 1)로 가면 45로, (1, 0)으로 가면 35로, 현재 위치인 (0, 0)의 값 50보다 작습니다. 따라서 (0, 1)과 (1, 0)으로 갈 수 없습니다. 이 경우, dfs(0, 0)은 0을 반환합니다.

그 다음, dfs(1, 0)이 호출되면 (1, 0)에서 출발하여 도착지점까지 도달하는 경우의 수를 구하게 됩니다. 이때, 이미 방문한 위치에서 출발하는 경우의 수가 dp 배열에 저장되어 있지 않으므로, dfs(1, 0)은 dfs(2, 0)과 dfs(1, 1)을 호출하여 이들의 반환값을 누적합니다.

(2, 0)에서 갈 수 있는 위치는 오른쪽 (2, 1)과 아래쪽 (3, 0)입니다. (2, 1)로 가면 22로, (3, 0)으로 가면 27로, 현재 위치인 (2, 0)의 값 30보다 작습니다. 따라서 (2, 1)과 (3, 0)으로 갈 수 없습니다. 이 경우, dfs(2, 0)은 0을 반환합니다.

(1, 1)에서 갈 수 있는 위치는 오른쪽 (1, 2), 아래쪽 (2, 1), 위쪽 (0, 1)입니다. (1, 2)로 가면 40으로, (2, 1)로 가면 25로, (0, 1)로 가면 45로, 현재 위치인 (1, 1)의 값 50보다 작습니다. 따라서 (1, 2), (2, 1), (0, 1)로 갈 수 있습니다. 이 경우, dfs(1, 1)은

dfs(1, 2)를 호출하고, dfs(1, 2)에서 갈 수 있는 위치는 오른쪽 (1, 3)입니다. (1, 3)으로 가면 20으로, 현재 위치인 (1, 2)의 값 40보다 작습니다. 따라서 (1, 3)으로 갈 수 있습니다. 이 경우, dfs(1, 2)는 1을 반환합니다.

dfs(1, 1)에서 dfs(1, 2)의 반환값 1을 누적하고, dfs(2, 1)을 호출합니다. dfs(2, 1)에서 갈 수 있는 위치는 오른쪽 (2, 2)과 아래쪽 (3, 1)입니다. (2, 2)로 가면 17로, (3, 1)로 가면 24로, 현재 위치인 (2, 1)의 값 25보다 큽니다. 따라서 (2, 2)과 (3, 1)으로 갈 수 없습니다. 이 경우, dfs(2, 1)은 0을 반환합니다.

dfs(1, 1)에서 dfs(2, 1)의 반환값 0을 누적하고, dfs(0, 1)을 호출합니다. dfs(0, 1)에서 갈 수 있는 위치는 오른쪽 (0, 2)입니다. (0, 2)로 가면 37로, 현재 위치인 (0, 1)의 값 45보다 작습니다. 따라서 (0, 2)로 갈 수 있습니다. 이 경우, dfs(0, 1)은 1을 반환합니다.

dfs(1, 1)에서 dfs(0, 1)의 반환값 1을 누적하고, dfs(1, 0)은 이제 dp 배열에 (1, 0)에서 출발하여 도착지점 (3, 4)까지 도달하는 경우의 수를 저장하고, 이 값 2를 반환합니다.

dfs(0, 0)은 이제 dp 배열에 (0, 0)에서 출발하여 도착지점 (3, 4)까지 도달하는 경우의 수를 저장하고, 이 값 2를 반환합니다.

따라서, 입력으로 주어진 지도에서 (0, 0)에서 출발하여 (3, 4)에 도달하는 경우의 수는 2입니다.


"""
import sys
sys.setrecursionlimit(10 ** 8)
input = sys.stdin.readline

# def dfs() : 현재 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 구하는 함수 
# dp 배열을 이용하여 이미 방문한 위치에서 출발하는 경우의 수를 미리 저장
# 이를 활용하여 재귀적으로 dfs 함수 호출 

def dfs(sx, sy): # 4. dfs 함수에서 현재 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 반환

    # 도착 지점에 도달하면 1(한 가지 경우의 수)를 리턴
    if sx == m-1 and sy == n-1:
        return 1
    # 5. 이때, 이미 방문한 위치에서 출발하는 경우의 수가 dp 배열에 저장되어 있다면 이를 활용하여 중복 계산을 방지
    # 이미 방문한 적이 있다면 그 위치에서 출발하는 경우의 수를 리턴
    if dp[sx][sy] != -1:
        return dp[sx][sy]
    
    ways = 0
    # dfs 함수에서는 현재 위치에서 갈 수 있는 위치를 모두 확인하며, 
    # 각 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 누적하여 반환
    for i in range(4):
        nx = sx + dx[i]
        ny = sy + dy[i]
        if 0 <= nx < m and 0 <= ny < n and graph[sx][sy] > graph[nx][ny]:
            # 예를 들어, 현재 위치에서 갈 수 있는 다음 위치가 3개이고, 그 다음 위치들에서 갈 수 있는 경우의 수가 각각 2, 3, 4라면, 
            # ways는 2+3+4인 9가 된다.
            # 따라서 ways 변수에는 현재 위치에서 도착 지점까지 갈 수 있는 모든 경로의 수가 누적된다.
            ways += dfs(nx, ny)

    # dfs 함수의 실행이 종료되면, 
    # 시작 위치에서 출발하여 도착지점까지 도달하는 경우의 수가 dp 배열에 저장된다.
    dp[sx][sy] = ways
    return dp[sx][sy]

# m, n: 각각 지도의 세로, 가로 길이
m, n = map(int, input().split()) 

# graph: 지도를 나타내는 2차원 배열
# 1. 입력받은 지도를 graph에 저장
graph = [list(map(int, input().split())) for _ in range(m)]

# dp: 이미 방문한 위치에서 출발하는 경우의 수를 저장하는 2차원 배열
# 2. 각 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 저장하기 위해 dp 배열을 -1로 초기화
dp = [[-1] * n for _ in range(m)]

# dx, dy: 상, 하, 좌, 우로 이동하는 경우의 좌표 차이를 나타내는 리스트
dx, dy = [1,-1,0,0], [0,0,1,-1]

# 3. dfs 함수를 호출하여 시작 위치 (0, 0)에서 출발하여 도착지점까지 도달하는 경우의 수를 구한다.
print(dfs(0,0))

# dfs 함수의 실행이 종료된 후, dfs(0,0)을 출력하여 
# 시작 위치에서 출발하여 도착지점까지 도달하는 경우의 수를 출력
