"""
#이 코드는 입력으로 주어지는 N개의 정수 중에서 두 개를 선택하여, 그 합이 0에 가장 가까운 값을 만드는 문제를 투 포인터(Two-Pointer) 알고리즘을 사용하여 해결합니다.

#우선, 입력으로 주어진 N개의 정수를 리스트(array)에 저장하고, 오름차순으로 정렬합니다. 그리고 투 포인터(Two-Pointer) 알고리즘을 사용하기 위해 start와 end 변수를 초기화합니다. 
#start 변수는 리스트(array)의 가장 작은 값(인덱스 0), end 변수는 리스트(array)의 가장 큰 값(인덱스 N-1)으로 설정합니다.

#그리고 나서, 합의 절대값이 최소인 두 용액의 쌍을 구하는 과정을 반복합니다. 
#용액의 쌍을 구하기 위해 pair 변수를 None으로 초기화하고, 합의 절대값이 최소인 두 용액의 쌍을 저장합니다. 
#초기값으로 무한대를 사용하여 min_sum 변수를 초기화합니다.

#이후, start와 end의 값을 이용하여 리스트(array)의 값들의 합을 구합니다. 현재 위치의 start와 end 인덱스에 해당하는 값들의 합을 current_sum 변수에 저장합니다. 
#그리고 합의 절대값이 최소인 두 용액의 쌍을 구하기 위해, current_sum의 절대값이 현재까지 구한 최소값(min_sum)보다 작으면 min_sum 변수를 갱신하고, pair 변수에 현재의 두 용액 값을 저장합니다.

#이어서, 합이 0보다 크면 end 인덱스를 왼쪽으로 한 칸 이동시키고, 합이 0보다 작으면 start 인덱스를 오른쪽으로 한 칸 이동시킵니다. 
#이 과정을 start와 end가 같아질 때까지 반복합니다.

#마지막으로, 합의 절대값이 최소인 두 용액의 쌍(pair)을 출력합니다.

#초기값으로 무한대를 사용하는 이유는, 합의 절대값이 최소인 두 용액의 합을 구하는 과정에서, 최솟값을 구하기 위해 비교할 값보다 더 작은 값을 초기값으로 지정해 두어야 하기 때문입니다.

#만약 초기값을 배열의 첫 번째 원소로 지정하면, 최솟값을 구하기 위해 비교할 값보다 항상 큰 값을 가져야 합니다. 이렇게 되면, 합의 절대값이 최소인 두 용액의 합이 0보다 크면서 배열의 첫 번째 원소보다 작은 경우에는 올바른 결과가 나오지 않을 수 있습니다.

#따라서, 무한대를 초기값으로 지정하면, 합의 절대값이 0보다 작아지는 경우가 없으므로 항상 올바른 결과가 나오게 됩니다.

"""
n=int(input())
array = list(map(int,input().split()))
array.sort()

start = 0 #인덱스 0
end = n-1 #가장 큰 값(인덱스 n-1)

min_sum = float('inf') #무한대로 초기화

# pair를 None으로 설정한 이유는, 최소값을 갱신할 때, 합의 절대값이 최소인 두 용액의 쌍을 저장하기 위해서
# 초기에는 합의 절대값이 최소인 두 용액의 쌍을 모르기 때문에, pair를 None으로 설정
pair = None #합의 절대값이 최소인 두 용액의 쌍

while start < end:
    current_sum = array[start] + array[end]
    
    # abs(current_sum)의 값이 현재까지 구해진 최소값 min_sum보다 작을 경우에만 최소값을 갱신
    if abs(current_sum) < min_sum:
        min_sum = abs(current_sum)
        pair = (array[start],array[end])
    
    if current_sum > 0:
        end -= 1
    else:
        start += 1

print(pair[0],pair[1])
