"""
주어진 집들 중에서 최대 거리를 찾아 그 거리 이상으로는 인접한 두 집에 공유기를 설치하고, 그렇게 설치한 공유기의 수가 C개가 되도록 하는 것이 목표입니다.

이 문제를 해결하기 위해서는 이진 탐색을 이용하여 최대 거리를 구해나가는 방식을 사용합니다. 구체적인 알고리즘은 다음과 같습니다.

주어진 집들을 좌표의 오름차순으로 정렬합니다.
이진 탐색을 수행합니다. 이때, 탐색 범위는 가장 가까운 두 집 사이의 거리에서부터 시작하여 가장 먼 두 집 사이의 거리까지로 설정합니다.
이진 탐색을 수행하면서 각 단계마다 설치한 공유기의 개수를 계산합니다.
이진 탐색을 마치면, 마지막으로 찾은 최대 거리가 문제에서 요구하는 결과입니다.
이 알고리즘을 구현하여 문제를 해결할 수 있습니다.

Q. 이 문제를 이진탐색으로 풀어야 하는 이유가 뭐야? 문제의 어느 부분을 보고 알 수 있을까?

이 문제에서 이진 탐색을 이용하는 이유는, 설치할 공유기의 개수를 C로 고정하고 최대 거리를 찾아내는 것이 문제의 목적이기 때문입니다. 
즉, 우리는 최대 거리를 이진 탐색을 통해 찾아나가면서, 그 거리 이상으로 설치할 수 있는 공유기의 수가 C개 이상인지 확인하면서 답을 찾아가는 것입니다.

따라서, 이 문제에서 이진 탐색을 사용하려면 주어진 집들의 위치를 정렬한 뒤, 이진 탐색을 수행하는데, 
탐색의 범위를 가장 가까운 두 집 사이의 거리에서부터 가장 먼 두 집 사이의 거리까지로 설정합니다. 
그리고 이진 탐색을 수행하면서 각 단계마다 설치한 공유기의 개수를 계산하고, 이 개수가 C보다 크거나 같으면 최대 거리를 갱신합니다.

따라서, 문제의 설명 중에서 "인접한 두 집 사이의 거리가 최대가 되도록 공유기를 설치하려고 합니다" 라는 문장에서 이 문제에서 이진 탐색을 사용해야 함을 유추할 수 있습니다.

Q. if count >= C 일때  start = mid + 1 인 이유 ?

예를 들어, houses 리스트가 [1, 2, 4, 8, 9]이고, C가 3이라고 가정합니다. 
이 경우, 이진 탐색의 초기 상태에서 start는 1이고, end는 8입니다. 따라서 중간값인 mid는 4가 됩니다. 
이 경우, get_count_of_routers(houses, mid) 함수를 실행하면 공유기가 2개 설치됩니다. 즉, count는 2입니다.

count가 C보다 작으므로, mid를 줄여서 최대 거리를 줄여야 합니다. 이 경우, end를 mid-1로 변경합니다. 
그리고 다시 이진 탐색을 수행합니다. 이번에는 mid는 2가 됩니다. get_count_of_routers(houses, mid) 함수를 실행하면 공유기가 3개 설치됩니다. 즉, count는 3입니다.

count가 C보다 크거나 같으므로, mid를 늘려서 최대 거리를 늘려야 합니다. 이 경우, start를 mid+1로 변경합니다. 다시 이진 탐색을 수행합니다. 
이번에는 mid는 3이 됩니다. get_count_of_routers(houses, mid) 함수를 실행하면 공유기가 2개 설치됩니다. 즉, count는 2입니다.

Q. if array[i] >= current + distance: 면 공유기 설치하는 이유?

if array[i] >= current + distance: 구문은, i번째 집이 현재까지 설치한 공유기 중 가장 마지막에 설치된 공유기로부터 distance 이상 떨어져 있을 때, 
새로운 공유기를 설치하는 것을 의미합니다.

여기에서 distance는 이진 탐색을 통해 구한 공유기 사이의 최대 거리를 나타냅니다.

예를 들어, current가 1, distance가 2일 때, 가장 마지막에 설치된 공유기가 있는 위치가 3이라면, i번째 집이 5번째 집이라면, 
if array[i] >= current + distance: 구문은 array[5] >= 3 + 2와 같이 계산됩니다. 
이는 5번째 집이 가장 마지막에 설치된 공유기로부터 2 이상 떨어져 있으므로, 새로운 공유기를 설치해야 함을 의미합니다.

따라서 if array[i] >= current + distance: 구문을 만족하는 집이 있다면, 해당 집에 공유기를 설치해야 합니다.

"""
# 이 문제에서 이진 탐색을 이용하는 이유는, 
# 설치할 공유기의 개수를 C로 고정하고 최대 거리를 찾아내는 것이 문제의 목적이기 때문
# => "인접한 두 집 사이의 거리가 최대가 되도록 공유기를 설치하려고 합니다" 라는 문장에서 
# => 이 문제에서 이진 탐색을 사용해야 함을 유추할 수 있다.

def binary_search(array,distance): #array, mid / 이때 distance : 이진탐색을 통해 구한 공유기 사이의 최대 거리
    count = 1 # 첫번째 집에는 무조건 설치
    current = array[0]
    for i in range(1, len(array)):
        # i 번째 집이 현재까지 설치한 공유기 중 가장 마지막에 설치된 공유기로부터 'distance'이상 떨어져 있을 때 새로운 공유기 설치
        if array[i] >= current + distance: 
            # 공유기 설치
            count += 1
            current = array[i]
    return count 


n,m = map(int,input().split())

array = [int(input()) for _ in range(n)]

array.sort()

start = 1 # 최소 거리
end = array[-1] - array[0] # 최대 거리
answer = 0 # 정답

while start <= end:
    # mid : 이진 탐색 중간값으로, 이 값은 공유기 사이의 최대 거리를 나타냄 
    mid = (start+end) // 2

    count = binary_search(array,mid)

    if count >= m:
        start =  mid + 1
        answer = mid 
    else:
        end = mid - 1
print(answer)
