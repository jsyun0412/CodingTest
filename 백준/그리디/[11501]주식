"""
처음 작성한 코드는 다음과 같다.
t=int(input())
for i in range(t):
    n=int(input())
    a=[]
    res=[]
    answer = 0
    cnt=0
    max_item = 0

    a=list(map(int,input().split()))

    start = a[0]
    res.append(start)

    b=sorted(a,reverse=True)
    c=sorted(a)

    if a == b: #10 7 6
        print(0)
        continue
    

    elif a == c: #3 5 9
        for i in range(n):
            answer += (a[-1]-a[i])
        continue
      

    else: #1 1 3 1 2
        for i in range(1,n-1):
            if a[i] - start < 0:
                start = a[i]
      
            elif a[i] - start >= 0:
                res.append(a[i])
                start = a[i]

                if a[i] > a[i+1]:
                    max_item = a[i]
                    for i in res:
                        cnt = (max_item - i)
                        answer += cnt
                    max_item = 0
                pass

    if a[-2] < a[-1]:
        answer += (a[-1] - a[-2])
    


    print(answer)
    
    해당 코드 제출시 시간초과 에러 발생. 
    
    분석한 해당 코드의 문제점은 다음과 같다.
    
    1.불필요한 리스트 생성
    코드에서는 주어진 입력값에 대해 리스트를 생성하고 정렬함. 그러나 이는 불필요한 작업이며, 시간을 많이 소비함.

    2. 중복된 코드
    두 번째 조건에서는 for문 안에 단순히 합을 구하는 코드가 있다. 그러나 이는 세 번째 조건에서도 필요한 부분이다. 이 부분을 함수로 따로 빼는 것이 효율적

    3.불필요한 연산
    코드에서는 최대 이익을 계산하기 위해 리스트를 사용. 그러나 리스트에 append() 함수를 사용하면서 불필요한 연산이 발생
    
    따라서 이러한 문제점을 해결하여 코드를 수정하였다. 
    
"""
t=int(input())
for i in range(t):
    n=int(input())
    a=list(map(int,input().split()))

    max_price = a[-1]
    answer = 0

    for j in range(n-2,-1,-1): #뒤에서 부터 순회
        if a[j] > max_price:
            max_price = a[j]
        else:
            answer += max_price - a[j]

    print(answer)
    
    """
    위의 코드는 입력값에 대해 리스트를 생성하지 않고, for문을 한 번만 사용해 최대 이익을 구하는 것이 특징이다. 
    
    이 코드는 각 테스트 케이스마다 입력받은 일별 주식 가격을 토대로, 최대 이익을 계산하는 프로그램이다.

    코드는 다음과 같은 순서로 진행된다.

    1.테스트 케이스 개수를 입력받음
    2.각 테스트 케이스마다, 일수와 일별 주식 가격을 입력받음
    3.입력받은 가격을 토대로 최대 이익을 계산
    
    최대 이익을 계산하는 방법은 다음과 같다.

    만약 일별 주식 가격이 모두 내림차순으로 정렬되어 있다면, 이익은 0. 그래서 바로 0을 출력하고 다음 테스트 케이스로 넘어감
    
    만약 일별 주식 가격이 모두 오름차순으로 정렬되어 있다면, 첫 번째 날에 주식을 사서 마지막 날에 팔면 최대 이익을 얻을 수 있다. 
    그래서 첫 번째 날의 가격을 기준으로 모든 날의 가격 차이를 더해 출력
    
    만약 일별 주식 가격이 섞여 있다면, 그리디 알고리즘을 이용하여 최대 이익을 구한다. 
    현재 가격보다 높은 가격이 나올 때까지는 주식을 사지 않고, 높은 가격이 나오면 그 때 모든 주식을 팔고 이익을 계산. 
    이후 다시 주식을 사지 않고 높은 가격이 나올 때까지 기다린다. 이를 모든 일자에 대해 반복하며 최대 이익을 계산한다. 
    마지막 날의 가격이 그 전 날의 가격보다 높다면, 마지막 날에 그 전 날에 가지고 있던 모든 주식을 팔아 최대 이익을 구한다.
    하지만 이 코드는 시간 복잡도가 O(N^2)으로 상당히 느리기 때문에, 테스트 케이스의 개수와 일수가 많아지면 시간 초과가 발생할 가능성이 높다.
    따라서 더 효율적인 알고리즘을 구현해야 한다.
    
    >>79번째 line해설 : for j in range(n-2,-1,-1) 로 뒤에서부터 순회하는 이유는 다음과 같다. 
    주어진 주식 가격을 순회하면서, 마지막 날 부터 시작하여 현재 날짜를 기준으로 이전까지의 최대 주식 가격을 저장하는데, 만약 현재 날짜의 주식 가격이 이전 최대 주식 가격보다
    작은 경우, 이 차이만큼 이익을 계산하고 이익을 answer에 더한다. 
    이렇게 뒤에서 순회하는 방식으로 반복문을 돌리는 이유는 이전까지의 최대 주식 가격과 비교하기 때문에, 코드의 효율성이 앞에서 순회할 때 보다 더 높아진다. 따라서 뒤에서부터 
    순회하는 것이 좀 더 효율적인 알고리즘이 된다. 
    """
